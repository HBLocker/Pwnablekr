# RSA overview and expenponant attack overview. 

I was doing a CTF on HTB which I begnn to find reather challanging as I have not really looked into ways in which RSA can be broken never mind put it into a practical example. 

 I will cover in this post a basic overview of RSA and how the attack works and explain the SAGE code written. 

 - What is RSA?

 - What is an exponant attack?


# Algorithm overview 


This is the first step to obtain bot public and private keyes. 
- Compute the following: n = p*q 

- Find a large intiger d which is releative prime to the intiger (p-1) (q-1)

- Compute a uniuqe intiger e in the range of 1 < e <(p-1)(q-1) This is our exponant. 
ed = (mod(p-1)(q-1))

- Make the public key which consists of the following pair of intigers (e,n)

- The message will be defined as M to be transmitted in the range of {1.....n} to break M into blocks if the message is to large. 

- Encrypt M into the cryptogram C by the following rule:
C = M^e (mod n)

Decryption is obtained with using the private key. 

D = M^d (mod n)

### Expontant overview 

An exponant in the RSA algorithm refers to the power which a number is raised. 
The RSA algorithm uses two exponants; public and privite. 

The exponant is deoted as E and used in the encryption procsess. This is used as part of the public key to encrypt messages. The exponant is a small number ranging from (3....65537) and is chosen that is is coprime to the numbers relative to the prime numbers of n =p*q. 

The private exponent, often denoted as "d," is used in the decryption process. It is a part of the private key and is used to decrypt messages. The private exponent is computed such that d * e ≡ 1 (mod φ(n)), where φ(n) = (p-1) * (q-1) and e is the public exponent. In other words, d and e are multiplicative inverses of each other modulo φ(n).

### Low Public Exponent RSA

The attack is somewhat trivial we have to say if the message was sent to three people first and the exponant is a low value such as 3. Each recipiant has a different modules N and each recipiant will recieve a different message. 

C = M^e (mod n)

If an attacker has acsess to C1...C3 they can recover the encrypted message M. We can assume that each modulus N is reletivly prime to one another othweqise the message can not be recoverd.  Since the modui are reletivly ptime we can soleve the equations for m^3 using chineese remainder theorem. 

### What is chineese Reaminder Theorem?

The Chinese Remainder Theorem (CRT) states that if we have two congruences (modular equations) of the form:

x ≡ a1 (mod m1)
x ≡ a2 (mod m2)

where m1 and m2 are relatively prime, then there exists a unique solution x for x in the range 0 < x < m1m2.

In the RSA system, we have the following two congruences:

m1^e ≡ c1 (mod N)
m2^e ≡ c2 (mod N)

Using the CRT, we can combine these two congruences into a single equation that gives us the value of m1m2 (mod N), which is equal to m1m2 (mod pq). Then, using the prime factorization of N, we can find m1 and m2.


### Putting it all together

Now we have a somewhat understanding of the theory behing this attack, lets put it all together and use it! 

https://app.hackthebox.com/challenges/quick-maffs

The challange is as follows:

Why does maths have to be so hard? Because some dudes with "degrees" decided there have to be 4529837459872034759 different equations and 347293475923709458 different fields instead of just pure numbers.




we are prestended with the following sage code 
``` sage
from Crypto.Util.number import *
from secret import pts,p,q

e = random_prime(2^10) 

N = p*q
pts = [bytes_to_long(i) for i in pts]
cts = [pow(i,e,N) for i in pts]
hint = sum(pts) 
print(f"{N},{cts},{hint}")


output.txt 

5981664384988507891478572449251897296717727847212579781448791472718547112403550208352320926002397616312181279859738938646168022481824206589739320298482728968548378237391009138243024910596491172979923991673446034011260330224409794208875199561844435663744993504673450898288161482849187018770655419007178851937895764901674192425054643548670616348302447202491340266057221307744866082461604674766259695903766772980842036324667567850124019171425634526227426965833985082234968255176231124754301435374519312001547854794352023852342682220352109083558778402466358598254431167382653831478713628185748237886560605604945010671417,[4064195644006411160585797813860027634920635349984344191047587061586620848352019080467087592184982883284356841385019453458842500930190512793665886381102812026066865666098391973664302897278510995945377153937248437062600080527317980210967973971371047319247120004523147629534186514628527555180736833194525516718549330721987873868571634294877416190209288629499265010822332662061001208360467692613959936438519512705706688327846470352610192922218603268096313278741647626899523312431823527174576009143724850631439559205050395629961996905961682800070679793831568617438035643749072976096500278297683944583609092132808342160168, 3972397619896893471633226994966440180689669532336298201562465946694941720775869427764056001983618377003841446300122954561092878433908258359050016399257266833626893700179430172867058140215023211349613449750819959868861260714924524414967854467488908710563470522800186889553825417008118394349306170727982570843758792622898850338954039322560740348595654863475541846505121081201633770673996898756298398831948133434844321091554344145679504115839940880338238034227536355386474785852916335583794757849746186832609785626770517073108801492522816245458992502698143396049695921044554959802743742110180934416272358039695942552488, 956566266150449406104687131427865505474798294715598448065695308619216559681163085440476088324404921175885831054464222377255942505087330963629877648302727892001779224319839877897857215091085980519442914974498275528112936281916338633178398286676523416008365096599844169979821513770606168325175652094633129536643417367820830724397070621662683223203491074814734747601002376621653739871373924630026694962642922871008486127796621355314581093953946913681152270251669050414866366693593651789709229310574005739535880988490183275291507128529820194381392682870291338920077175831052974790596134745552552808640002791037755434586],2674558878275613295915981392537201653631411909654166620884912623530781
```  

``` sage

from Crypto.Util.number import long_to_bytes

N = 5981664384988507891478572449251897296717727847212579781448791472718547112403550208352320926002397616312181279859738938646168022481824206589739320298482728968548378237391009138243024910596491172979923991673446034011260330224409794208875199561844435663744993504673450898288161482849187018770655419007178851937895764901674192425054643548670616348302447202491340266057221307744866082461604674766259695903766772980842036324667567850124019171425634526227426965833985082234968255176231124754301435374519312001547854794352023852342682220352109083558778402466358598254431167382653831478713628185748237886560605604945010671417


c1,c2,c3 = [4064195644006411160585797813860027634920635349984344191047587061586620848352019080467087592184982883284356841385019453458842500930190512793665886381102812026066865666098391973664302897278510995945377153937248437062600080527317980210967973971371047319247120004523147629534186514628527555180736833194525516718549330721987873868571634294877416190209288629499265010822332662061001208360467692613959936438519512705706688327846470352610192922218603268096313278741647626899523312431823527174576009143724850631439559205050395629961996905961682800070679793831568617438035643749072976096500278297683944583609092132808342160168, 3972397619896893471633226994966440180689669532336298201562465946694941720775869427764056001983618377003841446300122954561092878433908258359050016399257266833626893700179430172867058140215023211349613449750819959868861260714924524414967854467488908710563470522800186889553825417008118394349306170727982570843758792622898850338954039322560740348595654863475541846505121081201633770673996898756298398831948133434844321091554344145679504115839940880338238034227536355386474785852916335583794757849746186832609785626770517073108801492522816245458992502698143396049695921044554959802743742110180934416272358039695942552488, 956566266150449406104687131427865505474798294715598448065695308619216559681163085440476088324404921175885831054464222377255942505087330963629877648302727892001779224319839877897857215091085980519442914974498275528112936281916338633178398286676523416008365096599844169979821513770606168325175652094633129536643417367820830724397070621662683223203491074814734747601002376621653739871373924630026694962642922871008486127796621355314581093953946913681152270251669050414866366693593651789709229310574005739535880988490183275291507128529820194381392682870291338920077175831052974790596134745552552808640002791037755434586]

x = 2674558878275613295915981392537201653631411909654166620884912623530781

def solve_ctf(e):
    print(f"e = {e}: ")
    PR.<m1,m2,m3> = PolynomialRing(Zmod(N),3)
    # https://crypto.stackexchange.com/questions/6713/low-public-exponent-attack-for-rsa 
    t1 = m1**e -c1
    t2 = m2**e -c2
    t3 = m3**e -c3
    t4 = m1+m2+m3 - x 
    try:
        aa,bb,cc = Ideal([t1,t2,t3,t4]).grobner_basis()
        flag = long_to_bytes(int(N-(aa-m1))) + long_to_bytes(int(N-(bb-m2))) + long_to_bytes(int(N-(cc-m3)))
        print(flag)
    except:
        return

    quit()

def main(): 
    e = 4 
    while True:
        solve(e)
        e = next_prime(e)

if __name__ == "__main__":
    main()

```

https://cims.nyu.edu/~regev/teaching/lattices_fall_2004/ln/rsa.pdf

Domanic walsh codes and cryptography P180. 

https://crypto.stackexchange.com/questions/6713/low-public-exponent-attack-for-rsa

https://www.youtube.com/watch?v=zIFehsBHB8o
https://www.johndcook.com/blog/2019/03/06/rsa-exponent-3/
